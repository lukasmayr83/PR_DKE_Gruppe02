{% extends "base.html" %}

{% block content %}
<style>
    .segment-chain { max-width: 600px; }
    .segment-field { margin-bottom: 1rem; padding: 0.5rem; border: 1px solid #e5e7eb; border-radius: 0.5rem; background-color: #f9fafb; }
    select { width: 100%; padding: 0.5rem; border-radius: 0.375rem; border: 1px solid #d1d5db; }
</style>

<!-- Bindet die CSS-Datei add_edit.css für das Styling ein -->
<link rel="stylesheet" href="{{ url_for('static', filename='css/add_edit.css') }}">
<h1>Strecke hinzufügen</h1>
<div class="flex-container">

    <div class="form-wrapper">
        <form id="strecken-form" method="POST" action="{{ url_for('strecke_add') }}">

            {{ form.hidden_tag() }} <!-- CSRF-Token für Sicherheit (verhindert Cross-Site Request Forgery Angriffe) -->
            <!--Streckenname-->
            <p>
                {{ form.name.label }}<br>
                {{ form.name(class="form-control" + (" is-invalid" if form.name.errors else ""), id="name_input") }}
                <!-- zeigt Fehler an-->
                {% for error in form.name.errors %}
                    <div class="invalid-feedback" style="display: block;">
                        {{ error }}
                    </div>
                {% endfor %}
            </p>

            <!--Startbahnhof: Label + readonly Feld zum anzeigen des berechneten Startbahnhofs-->
            <p>
                <label for="startBahnhof">Startbahnhof der Strecke</label><br>
                <input type="text" id="startBahnhof" name="startBahnhof_display" class="form-control bg-light" readonly>
            </p>
             <!--endbahnhof: Label + readonly Feld zum anzeigen des berechneten Endbahnhofs-->
            <p>
                <label for="endBahnhof">Endbahnhof der Strecke</label><br>

                <input type="text" id="endBahnhof" name="endBahnhof_display" class="form-control bg-light" readonly>
            </p>
             <!--Abschnitte -->
            <h3 class="mt-4 mb-2">Abschnitts-Kette definieren</h3>


            <div id="segment-chain" class="segment-chain">

                <p class="text-gray-500" id="loading-message">Lade Abschnittsdaten...</p>
            </div>

            <input type="hidden" id="abschnitt_ids_hidden" name="abschnitt_ids" value="">
            <!-- Speichern + Abbrechen Button-->
            <p>
               {{ form.submit(class="btn btn-primary", id="submit-button") }}
                <a href="{{ url_for('warnung') }}" class="btn btn-secondary" style="margin-left: 10px;">Abbrechen</a>
            </p>
        </form>
        <!--Container für die Karte -->
    </div>
    <div class="map-wrapper">
        <div id="map" style="width:100%; height:100%;"></div>
    </div>
</div>

<!--JQuery-->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

<script>
    let allAbschnitte = []; //speichert alle Abschnitte
    let allBahnhoefe = {}; //ordnet BahnhofIds die Namen zu
    let selectedChain = []; //speichert vom Benutzer ausgewählte Abschnitte

    //lädt Daten vom Server per AJAX und initialisiert erstes Auswahlfeld
    function loadInitialData() {
        const apiUrl = "{{ api_url }}"; //ruft API api_abschnitte_daten auf

        //sendet Anfrage im Hintergrund ohne die Seite neu zu laden
        $.ajax({
            url: apiUrl, // URL der API
            method: 'GET', //GET-Methode -> Daten abrufen
            dataType: 'json', //JSON wird als Antwortformat erwartet
            success: function(data) { //falls alles geklappt hat
                $('#loading-message').remove(); //Lade-Nachricht "Lade Abschnitsdaten..." bei Erfolg entfernen

                if (data.abschnitte && data.bahnhoefe) { // Prüft ob die erwarteten Daten vorhanden sind
                    allAbschnitte = data.abschnitte; //speichert die empfangenen Abschnitte
                    allBahnhoefe = data.bahnhoefe; //speichert die empfangenen Bahnhöfe

                    if (allAbschnitte.length > 0) { // Prüft ob mindestens ein Abschnitt vorhanden ist
                        addNextSegmentField(0); //Startet die Kette (ruft dafür die Methode auf)
                    } else {
                        //keine Abschnitte vorhanden -> Warnmeldung
                        $('#segment-chain').html('<p class="text-warning">Keine Abschnitte in der Datenbank gefunden.</p>');
                    }
                } else {
                    // Fehlermeldung: unerwartetes Datenformat vom Server
                    $('#segment-chain').html('<p class="text-danger">Fehler: Unerwartetes Datenformat vom Server.</p>');
                }
            },
            error: function(jqXHR) { //falls ein Fehler auftritt
                $('#loading-message').remove(); // Entfernt Lade-Nachricht
                // Zeigt Fehlermeldung mit HTTP-Status-Code
                $('#segment-chain').html('<p class="text-danger">Fehler beim Laden (Status: ' + jqXHR.status + ')</p>');
            }
        });
    }

    //fügt ein neues Dropdown-Menü hinzu und zeigt nur verfügbare Abschnitte
    function addNextSegmentField(currentIndex) {
        //ermittelt vorherigen Endbahnhof
        const lastEndStationId = currentIndex > 0 ? selectedChain[currentIndex - 1].endBahnhofId : null;
        //ermittelt vorherige Spurweite
        const lastSpurweite = currentIndex > 0 ? selectedChain[currentIndex -1].spurweite : null;
        //ermittelt alle möglichen Abschnitte ausgehend von dem Bahnhof
        const filteredAbschnitte = allAbschnitte.filter(abschnitt => { //behält nur alle die true sind
            // Prüft ob dieser Abschnitt bereits in der Kette ausgewählt wurde
            const isAlreadySelected = selectedChain.some(s => s.abschnittId === abschnitt.abschnittId);

            // Beim ersten Dropdown: alle Abschnitte anzeigen
            if (currentIndex === 0) {
                return !isAlreadySelected; //gibt alle als true zurück
            } else { //falls nicht erster Abschnitt
                //nur Abschnitte  deren Startbahnhof der gleiche ist wie der Endbahnhof des Abschnitts zuvor, gleiche Spurweite und der noch nicht gewählt wurde
                return abschnitt.startBahnhofId === lastEndStationId && !isAlreadySelected && lastSpurweite === abschnitt.spurweite;
            }
        });

        //falls es keine passenden Abschnitte mehr gibt, wird kein neues Feld generiert
        if (filteredAbschnitte.length === 0 && currentIndex > 0) {
            return;
        }

        //erzeugt ein Dropdown Feld mit den gefilterten Abschnitten als Optionen
        const fieldHtml = `
            <div class="segment-field flex items-center space-x-2 bg-gray-50" data-index="${currentIndex}">
                <span style="min-width: 90px;" class="font-medium text-gray-600">Abschnitt:</span>
                <select class="segment-select" data-index="${currentIndex}">
                    <option value="">-- Abschnitt auswählen --</option>
                    ${filteredAbschnitte.map(a => `<option value="${a.abschnittId}">${a.name}</option>`).join('')}
                </select>
                <!--ab dem zweiten Dropdownfeld wird ein x-Button angezeigt mit dem die darauffolgenden Abschnitte und der mit dem x gelöscht wird -->
                ${currentIndex > 0 ? `<button type="button" class="remove-segment btn-danger text-lg">&times;</button>` : ''}
            </div>
        `;
        //Jquery-Funktion: fügt Dropdown unten an
        $('#segment-chain').append(fieldHtml);

}

    //ändern eines Feldes (wenn sich Dropdown zur Auswahl der Abschnitte ändert) -> entfernt alle nachfolgenden und erstellt das nächste Auswahlfeld
    $('#segment-chain').on('change', '.segment-select', function() {
        const index = parseInt($(this).data('index')); //index des Abschnitts der geändert wurde 0..erste Abschnitt
        const selectedId = parseInt($(this).val()); //id des Abschnitts

        //alle Abschnitte, die einen höheren Index haben und daher danach kommen, werden gelöscht
        //falls der abschnitt geändert wird
        $(`.segment-field[data-index]`).filter(function() {
            return parseInt($(this).data('index')) > index;
        }).remove();
        selectedChain.splice(index);//nachfolgenden Modelle im Array löschen

        if (selectedId) { //wenn Abschnitt gewählt
            const selectedAbschnitt = allAbschnitte.find(a => a.abschnittId === selectedId);
            selectedChain.push(selectedAbschnitt); //im Array dranhängen
            addNextSegmentField(index + 1); //nächste Dropdown erzeugen
        }
        updateDisplayAndButton(); //um UI-Elemente zu aktualisieren
    });

    //löscht den Abschnitt und alle nachfolgenden Abschnitte falls auf das X gedrückt wurde
    $('#segment-chain').on('click', '.remove-segment', function() { //reagiert auf löschen Button . remove-segment
        const fieldToRemove = $(this).closest('.segment-field'); //Dropdown das gelöscht werden soll
        const indexToRemove = parseInt(fieldToRemove.data('index')); //index des zu entfernenden Abschnitts

        //auch alle Abschnitte nach dem zu löschenden Abschnitt müssen gelöscht werden
        $(`.segment-field[data-index]`).filter(function() {
            return parseInt($(this).data('index')) >= indexToRemove;
        }).remove();
        //entfernt Elemente ab indexToRemove
        selectedChain.splice(indexToRemove);

        addNextSegmentField(selectedChain.length);//neues Dropdown erstellen

        updateDisplayAndButton();//UI-updaten
    });

    //UI, Start-und Endbahnhoffelder und Map aktualisieren
    function updateDisplayAndButton() {
    const ids = selectedChain.map(a => a.abschnittId); //erstellt Array, das nur die Ids der Abschnitte speichert

    //verstecktes Formularfeld, dass an das Backendübergeben wird
    $('#abschnitt_ids_hidden').val(ids.join(','));

    // Start- und Endbahnhof aktualisieren
    if (selectedChain.length > 0) {
        const startBhfId = selectedChain[0].startBahnhofId; //startBahnhof = Startbahnhof des ersten Abschnitts
        const endBhfId = selectedChain[selectedChain.length - 1].endBahnhofId; //endbahnhof = Endbahnhof des letzten Abschnitts

        $('#startBahnhof').val(allBahnhoefe[startBhfId] || 'Unbekannt'); //holt den Namen des Bahnhofs aus den übergebenen Bahnhöfen
        $('#endBahnhof').val(allBahnhoefe[endBhfId] || 'Unbekannt');
    } else { //keine Abschnitte ausgewählt -> Felder bleiben leer
        $('#startBahnhof').val('');
        $('#endBahnhof').val('');
    }

    // Karte aktualisieren
    drawSelectedSegments();
}




    //wird ausgeführt sobald das HTML-Dokument vollständig geladen wurde
    $(document).ready(function() {
    loadInitialData();//lädt erstes Dropdown

    //Formularvalidierung vor dem Start
    $('#strecken-form').on('submit', function(event) {
        let isValid = true; //Boolean-Variable für Validierungsstatus

        //entfernt alle alten Fehlermeldungen
        $('.validation-error').remove();
        $('.form-control').removeClass('is-invalid');

        const nameInput = $('#name_input'); //holt das Name-Input-Element
        if (nameInput.val().trim() === '') { //falls noch kein Name eingegeben wurde
            isValid = false; // Setzt Validierung auf falsch
            nameInput.addClass('is-invalid'); //Fehlermeldung
            nameInput.after('<div class="validation-error text-danger" style="margin-top:5px;">Bitte geben Sie einen Namen für die Strecke ein.</div>');
        }

        if (selectedChain.length === 0) { //falls noch keine Abschnitte ausgewählt wurden
            isValid = false; // Setzt Validierung auf falsch

            // Fügt Fehlermeldung nach dem segment-chain Container ein
            $('#segment-chain').after('<div class="validation-error text-danger" style="margin-top:5px;">Bitte wählen Sie mindestens einen Streckenabschnitt aus.</div>');
        }

        //wenn Validierung fehlgeschlagen ist
        if (!isValid) {
            event.preventDefault(); //verhindert das Absenden des Formulars
            //scrollt zum Fehler
            $('html, body').animate({
                scrollTop: $(".validation-error").first().offset().top - 100
            }, 500);
        }
    });
});
</script>

<!--CSS+JS für Leaflet (zum Erstellen der Karte)-->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script>
    //Karte erstellen
    let map = L.map('map').setView([47.5162, 14.5501], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    //LayerGroup für Linien und Marker
    let segmentsLayer = L.layerGroup().addTo(map);

    //wird aufgerufen wenn sich die Abschnitte ändern
function drawSelectedSegments() {
    // Verwendet selectedChain statt Dropdown-Werte
    let selectedIds = selectedChain.map(s => s.abschnittId);

    //löscht alle alten Dinge
    segmentsLayer.clearLayers();

    if (!selectedIds || selectedIds.length === 0) { //keine IDs -> beenden
        return;
    }

    //holt Koordinaten fürs Zeichnen aus der Datenbank
    let fetchPromises = selectedIds.map(id => {
        return fetch(`/api/abschnitt/${id}`).then(response => response.json());
    });

    //wartet bis alle Daten geladen wurden -> zeichnet dann alles auf einmal
    Promise.all(fetchPromises)
        .then(results => {
            let bounds = L.latLngBounds(); //Repräsentiert das anzuzeigende Rechteck

            //Iterieren über alle Abschnitte
            results.forEach(data => {
                if (data.start && data.end) {

                    //extrahiert die Koordinaten
                    let startLatLng = [data.start.lat, data.start.lon];
                    let endLatLng = [data.end.lat, data.end.lon];

                    //Linie zeichnen
                    let polyline = L.polyline([startLatLng, endLatLng], {
                        color: 'blue',
                        weight: 4, //Dicke der Linie
                        opacity: 0.7 //Transparenz 0.0 ganz transparent
                    }).addTo(segmentsLayer);

                    //Popup für Abschnitt
                    polyline.bindPopup(`<b>Abschnitt:</b> ${data.start.name} ➝ ${data.end.name}`);

                    //Marker für Startbahnhof
                    L.marker(startLatLng, {
                                    icon: L.icon({
                                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
                                        iconSize: [25, 41],
                                        iconAnchor: [12, 41],
                                        popupAnchor: [1, -34],
                                        shadowSize: [41, 41]
                                    })
                                })
                        .bindPopup(`<b>Startbahnhof:</b> ${data.start.name}`) //wenn man auf den Marker anklickt wird dieser Text angezeigt
                        .addTo(segmentsLayer);

                    //Marker für Endbahnhof
                    L.marker(endLatLng, {
                                    icon: L.icon({
                                        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
                                        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
                                        iconSize: [25, 41],
                                        iconAnchor: [12, 41],
                                        popupAnchor: [1, -34],
                                        shadowSize: [41, 41]
                                    })
                                })
                        .bindPopup(`<b>Ende:</b> ${data.end.name}`) //wenn man auf den Marker anklickt wird dieser Text angezeigt
                        .addTo(segmentsLayer);

                    //Bounds erweitern -> alles anzeigt
                    bounds.extend(startLatLng);
                    bounds.extend(endLatLng);
                }
            });

            if (bounds.isValid()) {
                //Karte auf Bounds zentrieren (ganze Strecke sichtbar sit mit Abstand zum Rand)
                map.fitBounds(bounds, {padding: [50, 50]});
            }
        })
        .catch(err => console.error("Fehler beim Laden der Abschnitte:", err));
}
</script>
{% endblock %}